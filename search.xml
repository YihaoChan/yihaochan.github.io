<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cpp容器的内存管理</title>
    <url>/post/56ebe54a.html</url>
    <content><![CDATA[<p>以C++中常用的vector、set为例，分析其数据在内存中的存储位置，并且探究容器内部内存释放的相关问题。</p>
<a id="more"></a>

<h1 id="1-容器变量在堆还是在栈上"><a href="#1-容器变量在堆还是在栈上" class="headerlink" title="1 容器变量在堆还是在栈上"></a>1 容器变量在堆还是在栈上</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">// 栈区定义vector变量v1</span></span><br><span class="line">    v1.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v1:             %p\n&quot;</span>, &amp;v1); <span class="comment">// 变量v1的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v1 first ele:   %p\n&quot;</span>, &amp;(v1[<span class="number">0</span>])); <span class="comment">// 数组v1中第一个元素的存储地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 栈区定义set变量s</span></span><br><span class="line">    s.insert(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s:              %p\n&quot;</span>, &amp;s); <span class="comment">// 变量s的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s first ele:    %p\n&quot;</span>, s.begin()); <span class="comment">// 集合s中第一个元素的存储地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2; <span class="comment">// 栈区定义vector变量v2</span></span><br><span class="line">    v2.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v2:             %p\n&quot;</span>, &amp;(v2)); <span class="comment">// 变量v2的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v2 first ele:   %p\n&quot;</span>, &amp;(v2[<span class="number">0</span>])); <span class="comment">// 数组v2中第一个元素的存储地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line">    Node n1; <span class="comment">// 栈上定义结构体对象，其成员变量也在栈上</span></span><br><span class="line">    n1.v.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n1:             %p\n&quot;</span>, &amp;(n1)); <span class="comment">// 变量n1的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n1.v:           %p\n&quot;</span>, &amp;(n1.v)); <span class="comment">// n1中的数组成员变量的存储地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n1.v[0]:        %p\n&quot;</span>, &amp;(n1.v[<span class="number">0</span>])); <span class="comment">// n1中数组的首元素存储地址</span></span><br><span class="line"></span><br><span class="line">    Node *n2 = <span class="keyword">new</span> Node(); <span class="comment">// 堆上定义结构体对象，这个变量在栈上，但它申请的内存在堆上</span></span><br><span class="line">    n2-&gt;v.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n2:             %p\n&quot;</span>, &amp;(n2)); <span class="comment">// 变量n2的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n2-&gt;v:          %p\n&quot;</span>, &amp;(n2-&gt;v)); <span class="comment">// n2中的数组成员变量的存储地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n2-&gt;v[0]:       %p\n&quot;</span>, &amp;(n2-&gt;v[<span class="number">0</span>])); <span class="comment">// n2中数组的首元素存储地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后运行可得：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v1:             000000000062fdd0</span><br><span class="line">v1 first ele:   0000000002652580</span><br><span class="line">s:              000000000062fda0</span><br><span class="line">s first ele:    00000000026525a0</span><br><span class="line">v2:             000000000062fd80</span><br><span class="line">v2 first ele:   00000000026525d0</span><br><span class="line">n1:             000000000062fd60</span><br><span class="line">n1.v:           000000000062fd60</span><br><span class="line">n1.v[0]:        00000000026525f0</span><br><span class="line">n2:             000000000062fd58</span><br><span class="line">n2-&gt;v:          0000000002652610</span><br><span class="line">n2-&gt;v[0]:       0000000002652630</span><br></pre></td></tr></table></figure>

<p>观察可知：06开头的地址的值不断减少，02开头的的地址的值不断增加，由此可判断，06开头为栈上的地址(栈向下生长)，02开头的地址为堆上的地址。</p>
<ol>
<li>由v1、s、v2的地址可知，创建容器时，定义容器的变量本身存放在栈上；</li>
<li>由v1的第一个元素、s的第一个元素、v2的第一个元素的地址可知，容器所存储的元素存放在堆上；</li>
<li>由n1、n2的地址可知，创建结构体对象时，不管是将分配的内存放在栈空间还是堆空间(new开辟)，其结构体变量都存放在栈上；</li>
<li>由n1和n1.v的地址可知，如果在栈上分配结构体内存的话，结构体的第一个成员的地址和定义结构体对象的变量的地址相等，且都在栈上；</li>
<li>由n2和n2-&gt;v的地址可知，如果在堆上分配结构体内存的话，指针变量本身存放在栈上，但该对象的成员变量都存放在堆上；</li>
<li>不管是在栈上还是堆上分配结构体对象的内存，其成员变量中如果有容器，那么容器中的数据都存放堆上。</li>
</ol>
<p>总结：</p>
<ol>
<li>vector、set容器中，其数据都动态存储在堆空间的内存上；</li>
<li>在栈区定义容器变量，变量本身存储在栈区，但是容器所存储的数据在堆区；</li>
<li>在堆空间定义的容器变量，成员变量本身存储在堆区，容器所存储的数据也在堆区。</li>
</ol>
<h1 id="2-容器释放内存"><a href="#2-容器释放内存" class="headerlink" title="2 容器释放内存"></a>2 容器释放内存</h1><p>我们往往会在一个程序中向vector中压入多个元素，在使用完vector中的元素之后，只是会用clear去清理vector中的元素，但清空容器就等于释放了内存吗？</p>
<h3 id="2-0-两个概念"><a href="#2-0-两个概念" class="headerlink" title="2.0 两个概念"></a>2.0 两个概念</h3><ul>
<li><p>capacity的意思是容量，此方法返回的是该vector对象最多能容纳多少个元素；</p>
</li>
<li><p>size的意思是大小，此方法是返回该vector对象当前有多少个元素。</p>
</li>
</ul>
<h3 id="2-1-实验一：clear"><a href="#2-1-实验一：clear" class="headerlink" title="2.1 实验一：clear()"></a>2.1 实验一：clear()</h3><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;psapi.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMemoryInfo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    HANDLE handle = GetCurrentProcess();</span><br><span class="line">    PROCESS_MEMORY_COUNTERS pmc;</span><br><span class="line">    GetProcessMemoryInfo(handle, &amp;pmc, <span class="keyword">sizeof</span>(pmc));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;memory: &quot;</span> &lt;&lt; pmc.WorkingSetSize / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;peek memory: &quot;</span> &lt;&lt; pmc.PeakWorkingSetSize / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;virtual memory: &quot;</span> &lt;&lt; pmc.PagefileUsage / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;peek virtual memory: &quot;</span> &lt;&lt; pmc.PeakPagefileUsage / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">double</span> temp = i / <span class="number">0.5</span>;</span><br><span class="line">        v.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---not clear---&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity: &quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    showMemoryInfo();</span><br><span class="line">    v.clear();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;---clear---&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity: &quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    showMemoryInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时加上<code>-lpsapi</code>选项。</p>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---not clear---</span><br><span class="line">capacity: 16777216</span><br><span class="line">memory: 85667K</span><br><span class="line">peek memory: 139751K</span><br><span class="line">virtual memory: 136581K</span><br><span class="line">peek virtual memory: 203853K</span><br><span class="line"></span><br><span class="line">---clear---</span><br><span class="line">capacity: 16777216</span><br><span class="line">memory: 85667K</span><br><span class="line">peek memory: 139751K</span><br><span class="line">virtual memory: 136581K</span><br><span class="line">peek virtual memory: 203853K</span><br></pre></td></tr></table></figure>

<p>可以看到，clear()并没有真正释放内存。实际上，clear()只是将容器的size置为0，但没有改变capacity。</p>
<h3 id="2-2-clear-shrink-to-fit"><a href="#2-2-clear-shrink-to-fit" class="headerlink" title="2.2 clear() + shrink_to_fit()"></a>2.2 clear() + shrink_to_fit()</h3><p>C++11有了一个全新的shrink_to_fit()方法，该方法与clear()搭配使用，将vector所占用大小缩小到合适的范围。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;psapi.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMemoryInfo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    HANDLE handle = GetCurrentProcess();</span><br><span class="line">    PROCESS_MEMORY_COUNTERS pmc;</span><br><span class="line">    GetProcessMemoryInfo(handle, &amp;pmc, <span class="keyword">sizeof</span>(pmc));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;memory: &quot;</span> &lt;&lt; pmc.WorkingSetSize / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;peek memory: &quot;</span> &lt;&lt; pmc.PeakWorkingSetSize / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;virtual memory: &quot;</span> &lt;&lt; pmc.PagefileUsage / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;peek virtual memory: &quot;</span> &lt;&lt; pmc.PeakPagefileUsage / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">double</span> temp = i / <span class="number">0.5</span>;</span><br><span class="line">        v.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---not shrink---&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity: &quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    showMemoryInfo();</span><br><span class="line">    v.clear();</span><br><span class="line">    v.shrink_to_fit();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;---shrink---&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity: &quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    showMemoryInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时加上<code>-lpsapi</code>选项。</p>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---not clear---</span><br><span class="line">capacity: 16777216</span><br><span class="line">memory: 85651K</span><br><span class="line">peek memory: 139759K</span><br><span class="line">virtual memory: 136581K</span><br><span class="line">peek virtual memory: 203878K</span><br><span class="line"></span><br><span class="line">---clear---</span><br><span class="line">capacity: 0</span><br><span class="line">memory: 5615K</span><br><span class="line">peek memory: 139759K</span><br><span class="line">virtual memory: 2093K</span><br><span class="line">peek virtual memory: 203878K</span><br></pre></td></tr></table></figure>

<p>可以看到，使用shrink_to_fit方法搭配clear方法可以快速释放掉vector所占用的内存，且capacity也变为0。</p>
<h3 id="2-3-swap"><a href="#2-3-swap" class="headerlink" title="2.3 swap()"></a>2.3 swap()</h3><p>swap交换技巧实现内存释放思想：vector()使用vector的默认构造函数建立临时vector对象，再在该临时对象上调用swap成员函数。用swap(v)把原来的vector拷贝至一个全新的临时vector，然后原有的vector就会被自然销毁。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;psapi.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMemoryInfo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    HANDLE handle = GetCurrentProcess();</span><br><span class="line">    PROCESS_MEMORY_COUNTERS pmc;</span><br><span class="line">    GetProcessMemoryInfo(handle, &amp;pmc, <span class="keyword">sizeof</span>(pmc));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;memory: &quot;</span> &lt;&lt; pmc.WorkingSetSize / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;peek memory: &quot;</span> &lt;&lt; pmc.PeakWorkingSetSize / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;virtual memory: &quot;</span> &lt;&lt; pmc.PagefileUsage / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;peek virtual memory: &quot;</span> &lt;&lt; pmc.PeakPagefileUsage / <span class="number">1000</span> &lt;&lt; <span class="string">&quot;K&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">double</span> temp = i / <span class="number">0.5</span>;</span><br><span class="line">        v.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---not swap---&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity: &quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    showMemoryInfo();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;().swap(v);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;---swap---&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity: &quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    showMemoryInfo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时加上<code>-lpsapi</code>选项。</p>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---not swap---</span><br><span class="line">capacity: 16777216</span><br><span class="line">memory: 85610K</span><br><span class="line">peek memory: 139751K</span><br><span class="line">virtual memory: 136581K</span><br><span class="line">peek virtual memory: 203845K</span><br><span class="line"></span><br><span class="line">---swap---</span><br><span class="line">capacity: 0</span><br><span class="line">memory: 5607K</span><br><span class="line">peek memory: 139751K</span><br><span class="line">virtual memory: 2093K</span><br><span class="line">peek virtual memory: 203845K</span><br></pre></td></tr></table></figure>

<p>可以看到，使用swap方法搭配也可以快速释放掉vector所占用的内存，且capacity也变为0。</p>
<p>总结：</p>
<ol>
<li>clear()并没有释放内存，仅仅改变了size；</li>
<li>真正释放内存要使用clear() + shrink_to_fit()，或者swap()。</li>
</ol>
]]></content>
      <categories>
        <category>Operation System</category>
      </categories>
      <tags>
        <tag>Memory Management</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim的系统剪贴板的奇妙发现</title>
    <url>/post/10c2209c.html</url>
    <content><![CDATA[<p>学习Vim的时候，接触了<code>yy</code>和<code>p</code>的Vim窗口内部复制与粘贴命令。但是有一次，在Vim中执行<code>yy</code>命令后，关闭Vim，想把复制到的整一行文字粘贴到已经关闭Vim了的终端上时，却一直无法粘贴，怎么按粘贴快捷键都是空白。对于这个问题有点搞不懂，就上网搜了一下，原来想要在Vim以外的进程上粘贴东西的时候，需要用到Vim里的<strong>系统剪贴板</strong>。但是，这个Vim的”系统”剪贴板，也不是真正的操作系统的”系统”剪贴板。</p>
<a id="more"></a>

<p>P.S. 以下过程均以Ubuntu 18.04.5操作系统为例进行演示。</p>
<h2 id="1-查看Vim是否支持系统剪贴板"><a href="#1-查看Vim是否支持系统剪贴板" class="headerlink" title="1. 查看Vim是否支持系统剪贴板"></a>1. 查看Vim是否支持系统剪贴板</h2><p>在终端中输入<code>vim --version | grep clipboard</code>，观察<strong>clipboard</strong>选项前的符号：如果为 <strong>-</strong> 号，说明当前的Vim不支持系统剪贴板，需要先在终端执行<code>sudo apt install vim-gnome</code>，之后再次执行<code>vim --version | grep clipboard</code>，可以看到<strong>clipboard</strong>选项前的符号为 <strong>+</strong> 号，表示当前的Vim已经支持系统剪贴板。</p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/Vim%E5%BC%80%E5%90%AFClipboard.png"></p>
<h2 id="2-查看Linux系统的系统剪贴板内容"><a href="#2-查看Linux系统的系统剪贴板内容" class="headerlink" title="2. 查看Linux系统的系统剪贴板内容"></a>2. 查看Linux系统的系统剪贴板内容</h2><p>执行<code>sudo apt install xclip</code>安装xclip，再执行<code>xclip -o</code>命令，就可以查看当前Linux系统的系统剪贴板内容。</p>
<p>e.g. 在终端上打印一串字符：</p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/%E7%BB%88%E7%AB%AF%E6%89%93%E5%8D%B0%E5%86%85%E5%AE%B9.png"></p>
<p>然后用鼠标选中，按下<code>ctrl + shift + c</code>复制：</p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/%E7%BB%88%E7%AB%AF%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9.png"></p>
<p>执行<code>xclip -o</code>命令查看系统剪贴板内容：</p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF.png"></p>
<p>此时可以看到，用户手动复制到了Linux的系统剪贴板的内容已经通过<code>xclip -o</code>成功显示。</p>
<h2 id="3-通过Vim的系统剪贴板将内容复制到Vim以外的地方"><a href="#3-通过Vim的系统剪贴板将内容复制到Vim以外的地方" class="headerlink" title="3. 通过Vim的系统剪贴板将内容复制到Vim以外的地方"></a>3. 通过Vim的系统剪贴板将内容复制到Vim以外的地方</h2><p>使用Vim打开任意一个文件，按下<code>Esc</code>进入命令模式，再执行<code>&quot;+yy</code>命令复制当前一整行至Vim的系统剪贴板，执行<code>:reg</code>查看Vim的寄存器，可以看到Vim的系统剪贴板寄存器(“+寄存器)已存放我们刚才复制的一整行内容。</p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/Vim%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%AF%84%E5%AD%98%E5%99%A8.png"></p>
<p>之后<strong>不要退出</strong>Vim窗口，打开任意一个Vim以外的地方，快捷键<code>ctrl + v</code>，可以看到在Vim中复制的内容已经粘贴到Vim以外的地方。</p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/%E5%A4%8D%E5%88%B6%E5%88%B0Vim%E4%BB%A5%E5%A4%96.png"></p>
<p>在Vim中执行<code>:wq</code>退出Vim窗口，再到另一个地方按下快捷键<code>ctrl + v</code>，可以发现，<strong>什么都没有</strong>。</p>
<p>当我好几次重复上述过程都发现，没有办法在关闭Vim的情况下粘贴已经在Vim中复制的内容的时候，我就开始有点怀疑了：Vim的系统剪贴板，到底是不是真正的”系统”剪贴板？</p>
<h2 id="4-结合xclip-o仔细观察"><a href="#4-结合xclip-o仔细观察" class="headerlink" title="4. 结合xclip -o仔细观察"></a>4. 结合xclip -o仔细观察</h2><p>在终端再次打印(Test for system clipboard.)并手动复制，然后执行<code>xclip -o</code>，可以看到Linux的系统剪贴板内容此时就是我们复制的内容。</p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/%E5%86%8D%E6%AC%A1xclip.png"></p>
<p>而当我们在Vim中通过命令模式执行<code>&quot;+yy</code>之后，我们可以的确可以将Vim中复制的内容原封不动地粘贴到Vim以外的地方。<strong>但是，</strong><code>xclip -o</code>查看到的却是我们之前在Vim以外的地方手动复制的内容。</p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/%E4%B8%A4%E6%AC%A1%E5%AF%B9%E6%AF%94.png" alt="&quot;Test for Vim clipboard.&quot;是我从Vim中复制并粘贴到终端上的内容，而&quot;Test for system clipboard.&quot;是我之前手动在终端上复制的内容。"></p>
<p>在Vim中执行<code>:wq</code>退出Vim窗口，再在终端按下快捷键<code>ctrl + shift +v</code>，什么都没有。但是执行<code>xclip -o</code>却还是查看到了之前我手动复制的内容。</p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/xclip%E7%9C%8B%E5%88%B0%E4%B9%8B%E5%89%8D.png" alt="&quot;空行&quot;是我关掉Vim后按下粘贴快捷键后显示的内容，而&quot;Test for system clipboard.&quot;是我之前手动在终端上复制的内容。"></p>
<h2 id="5-浅显通俗的猜想与拙见"><a href="#5-浅显通俗的猜想与拙见" class="headerlink" title="5. 浅显通俗的猜想与拙见"></a>5. 浅显通俗的猜想与拙见</h2><p>由此可见，Vim的”系统”剪贴板，并没有真正将内容拷贝到Linux的系统剪贴板上，当Vim这个进程被关闭了之后，Vim的”系统”剪贴板上的东西就会全部消失，并且也让Linux的系统剪贴板上的内容消失。</p>
<p>在与同学分享并讨论这个情况之后，我们用通俗的猜想去理解这个现象：在Vim中执行<code>&quot;+yy</code>命令后，VIm对Linux的粘贴快捷键进行了”劫持”。</p>
<p>在Vim进程未关闭的时候，我们去往Vim以外的任何地方进行粘贴，粘贴的内容都是保存在Vim的系统剪贴板寄存器中的内容，并且此时我们的粘贴快捷键粘贴的内容，已经和我们Linux的系统剪贴板上的内容<strong>没有任何关系</strong>。相当于，在Vim收到了<code>&quot;+yy</code>这个命令后，Vim”劫持”掉了我们Linux系统的粘贴快捷键，不管我们粘贴什么东西，都是来自于Vim的系统剪贴板寄存器。而在Vim进程关闭之后，自然Vim的寄存器随着Vim进程的关闭而消失，所以Vim的系统剪贴板寄存器中的内容被清空。而此时由于Linux的粘贴快捷键在之前已经被Vim”劫持”，并且Vim在关闭进程的时候也<strong>没有归还</strong>Linux的粘贴快捷键内容，因此，在Vim关闭后，不管我们怎么敲粘贴快捷键，都是一片空白。但<code>xclip -o</code>还是查看到了我们在Vim中复制之前的Linux系统剪贴板内容，可我们已经和它无缘。</p>
<h2 id="6-尝试将内容复制到Linux的系统粘贴板"><a href="#6-尝试将内容复制到Linux的系统粘贴板" class="headerlink" title="6. 尝试将内容复制到Linux的系统粘贴板"></a>6. 尝试将内容复制到Linux的系统粘贴板</h2><p>那么，如何真正做到在Vim中复制内容之后，即使在将Vim关闭之后，也能在其他地方粘贴呢？</p>
<h3 id="6-1-尝试1：进入Vim的可视模式"><a href="#6-1-尝试1：进入Vim的可视模式" class="headerlink" title="6.1 尝试1：进入Vim的可视模式"></a>6.1 尝试1：进入Vim的可视模式</h3><p>在Vim中按下<code>Esc</code>进入命令模式，再按下<code>v</code>进入可视模式。按左右方向键对字符进行选中，再按下y键进行复制。关闭Vim，敲下粘贴快捷键，<strong>一片空白。</strong></p>
<p>结论：可视模式无法将Vim中的内容复制到Linux的系统剪贴板。</p>
<h3 id="6-2-尝试2：让Vim进程进入后台"><a href="#6-2-尝试2：让Vim进程进入后台" class="headerlink" title="6.2 尝试2：让Vim进程进入后台"></a>6.2 尝试2：让Vim进程进入后台</h3><p>在Vim中按下<code>Esc</code>进入命令模式，再执行<code>&quot;+yy</code>命令复制当前一整行至Vim的系统剪贴板，按下Linux系统快捷键<code>ctrl + z</code>将Vim进程放到后台。此时Vim进程已经被放到后台，并处于suspended(暂停)状态。</p>
<p>执行<code>bg %1</code>命令让Vim进程在后台运行，可以看到Vim进程在continued状态之后还是切换到了suspended状态，执行<code>jobs</code>命令，Vim进程还是处于suspended状态。在任意一处按下Linux系统的粘贴快捷键，依旧是<strong>一片空白。</strong></p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/%E5%B0%86Vim%E6%94%BE%E5%88%B0%E5%90%8E%E5%8F%B0bg.png"></p>
<p>结论：将Vim进程放到后台，只能让Vim处于suspended状态，且无法让在Vim中的复制到Vim的系统剪贴板的内容进入Linux的系统剪贴板。</p>
<h3 id="6-3-尝试3：进入Vim的插入模式"><a href="#6-3-尝试3：进入Vim的插入模式" class="headerlink" title="6.3 尝试3：进入Vim的插入模式"></a>6.3 尝试3：进入Vim的插入模式</h3><p>在Vim中按下<code>Esc</code>进入命令模式，再按下<code>i</code>进入插入模式。用<strong>鼠标</strong>手动选中内容，并按下Linux系统的复制快捷键<code>ctrl + shift + c</code>复制。</p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/%E6%8F%92%E5%85%A5%E6%A8%A1%E5%BC%8F%E6%89%8B%E5%8A%A8%E5%A4%8D%E5%88%B6.png"></p>
<p>关闭Vim，敲下Linux的粘贴快捷键，<strong>成功</strong>将Vim中内容复制到Vim以外。此时执行<code>xclip -o</code>命令，可以看到Linux的系统剪贴板也显示我们在Vim中通过插入模式用鼠标选中并复制的内容。</p>
<p><img data-src="/images/Vim%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%89%AA%E8%B4%B4%E6%9D%BF%E7%9A%84%E5%A5%87%E5%A6%99%E5%8F%91%E7%8E%B0/%E6%8F%92%E5%85%A5%E6%A8%A1%E5%BC%8F%E6%89%8B%E5%8A%A8%E5%A4%8D%E5%88%B6-%E5%85%B3%E6%8E%89%E5%90%8E%E7%B2%98%E8%B4%B4.png"></p>
<p>结论：要想在关掉VIm之后，将在Vim中复制的内容送到Linux的系统剪贴板，需要在Vim中切换到插入模式，并用鼠标手动选中内容，再按下Linux系统的复制快捷键。之后即使关掉Vim，也能将内容粘贴到任意地方。<strong>但是</strong>，这不就违背了Vim的核心思想——“只通过键盘操作，解放鼠标操作”了吗？(滑稽)。</p>
<p>或许有人会说：在不关掉Vim的时候进行粘贴不就好了嘛。假设我需要把这部分复制的内容粘贴很多次，而且并非同时粘贴，可能是间断性不定时地粘贴，那么如果采用Vim的”系统”剪贴板进行复制粘贴的话，就意味着我需要一直开着这个Vim进程，不能人为/意外地关闭它。对于我这种强迫症来说，是接受不了的。对于不会用到的东西/进程，我一定选择丢弃~</p>
<h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><p>在发现这个现象后，我真的感叹开发Vim的这个功能的开发人员太太太聪明了！虽然…ta给我们带来了一些麻烦。所以，以后要将Vim中的内容复制到Vim外面的时候，切记<strong>不能</strong>退出Vim，否则怎么粘贴都没有用。如果在打开Vim之前用户自己有手动复制过某内容的话，那么在Vim中复制内容到Vim的系统剪贴板并退出Vim之后，也不会保留打开Vim之前复制的内容，只剩下一片空白。如果真要在关闭Vim之后还能获得在Vim中复制的内容，办法就是切换到Vim的插入模式，用鼠标进行选中和复制，之后不管关闭Vim与否，都可以进行粘贴。</p>
<p>至于我们的猜想到底对不对，等我有能力读懂Vim的源代码之后再下定论。</p>
]]></content>
      <categories>
        <category>Operation System</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次内网穿透</title>
    <url>/post/cb736208.html</url>
    <content><![CDATA[<h1 id="0-背景"><a href="#0-背景" class="headerlink" title="0 背景"></a>0 背景</h1><p>最近和同学在做大数据比赛，需要用到GPU服务器加速模型训练。而自己在家里，没有服务器资源可用。另一位同学在学校，他们的实验室有服务器，且可以(偷偷)拿来跑比赛要用的模型，但是只能用校园网才能连上。而我又需要经常用到服务器，总是发给他们跑也怪麻烦的，所以想到了一个办法——内网穿透。通过内网穿透，就可以实现从我自己(校外)的机器访问到校园内的实验室机器。此处特别感谢两位技术宅同学想到了这个办法！</p>
<p>一开始，A同学先用他自己已经租了的阿里云服务器配置好了一遍内网穿透。而我这几天也租(免费试用)了一个来玩玩，所以也想尝试下自己搭一下内网穿透。</p>
<a id="more"></a>

<h1 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1 环境配置"></a>1 环境配置</h1><p>为了减少多个IP、多个端口号在阐述时可能造成的误会，下面的例子都以真实场景的IP和端口号举例，除了屏蔽实验室机器用户名以保护同学的实验室的隐私。由于阿里云服务器只是试用一个月，后续大概率不会续费这个服务器，所以暴露服务器IP无大碍。</p>
<h2 id="1-1-公网VPS"><a href="#1-1-公网VPS" class="headerlink" title="1.1 公网VPS"></a>1.1 公网VPS</h2><p>实现内网穿透需要有一台固定IP的公网VPS，可用它作为跳板访问内网端口，而这台具有固定IP的公网VPS就是我目前已经在阿里云上配置好的公网服务器。</p>
<p>在阿里云控制台上查询到我租的公网服务器的<strong>公网IP</strong>为47.106.232.139：</p>
<p><img data-src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E5%85%AC%E7%BD%91IP.png"></p>
<h2 id="1-2-FRP"><a href="#1-2-FRP" class="headerlink" title="1.2 FRP"></a>1.2 FRP</h2><p>实现内网穿透的方式有多种，我们用的是FRP来实现。FRP(Fast Reverse Proxy)就是一个反向代理软件，它体积轻量但功能很强大，可以<strong>使处于内网或防火墙后的设备对外界提供服务</strong>，它支持HTTP、TCP、UDP等众多协议。我们今天仅讨论TCP和UDP相关的内容。</p>
<p>FRP结构很简单，分为frps和frpc两个可执行程序。<strong>在公网服务器上运行frps，在内网机器上运行frpc</strong>即可。</p>
<h2 id="1-3-端口"><a href="#1-3-端口" class="headerlink" title="1.3 端口"></a>1.3 端口</h2><p>约定用于<strong>frps和frpc进程运行时占用的端口</strong>号为7007，用于<strong>访问内网机器时内网机器开放的端口</strong>号为7777。这两个端口都要在阿里云的安全组上面开放。</p>
<p>在阿里云上添加安全组，开放两个端口：</p>
<ol>
<li>一个用于frps和frpc运行时占用的端口(下图中为7007)；</li>
<li>一个用于从外面的网络访问实验室机器时，内网机器所开放的端口(下图中为7777)。</li>
</ol>
<p><img data-src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E9%98%BF%E9%87%8C%E4%BA%91%E7%AB%AF%E5%8F%A3.png"></p>
<h1 id="2-免密连接服务器"><a href="#2-免密连接服务器" class="headerlink" title="2 免密连接服务器"></a>2 免密连接服务器</h1><p>由于每次ssh连接服务器时都需要输入密码，因此，如果能够保证安全又想节省时间的话，通过以下操作可去掉每次都要输入密码的环节，实现免密连接。</p>
<p>在<strong>本地机器</strong>创建密钥，一路回车：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure>

<p>把密钥从本地上传到服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">scp id_rsa.pub root@47.106.232.139:~&#x2F;tmp.pub</span><br></pre></td></tr></table></figure>

<p>登录<strong>服务器</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh root@47.106.232.139</span><br></pre></td></tr></table></figure>

<p>创建文件夹并写入信任名单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~&#x2F;.ssh</span><br><span class="line">cat ~&#x2F;tmp.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys</span><br><span class="line">rm ~&#x2F;tmp.pub</span><br></pre></td></tr></table></figure>

<p><strong>退出服务器</strong>，再ssh连接，发现不需要密码了，成功。</p>
<h1 id="3-FRP服务器端"><a href="#3-FRP服务器端" class="headerlink" title="3 FRP服务器端"></a>3 FRP服务器端</h1><p>阿里云服务器上面的命令行非常非常难用，执行命令很慢，而且用Vim按Esc的时候，只能把光标”移开”(具体效果不知道怎么描述)，根本没办法进入命令模式，所以千万不要用上面的shell，直接在本地用ssh连接阿里云服务器，用本地的终端操作即可。</p>
<p>ssh连接阿里云服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh root@47.106.232.139</span><br></pre></td></tr></table></figure>

<p>在公网服务器端下载FRP并解压，此处下载0.36.1版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.36.1&#x2F;frp_0.36.1_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf frp_0.36.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>吐槽一句，私以为阿里云这种级别会自己帮我们把各种网络啥的配置好，然后访问github就会快一点，没想到还是龟速，后来才得知租一台服务器其实也相当于拿到了一台什么都没有的机器。所以，如果wget下载github上的文件实在太慢的话，就找一下Github下载链接的镜像版本，这样就快很多。</p>
<p>因为<strong>公网服务器充当frp服务器端</strong>，所以只留下以下两个文件即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frps  frps.ini</span><br></pre></td></tr></table></figure>

<p>修改frps.ini配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim .&#x2F;frps.ini</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E5%85%AC%E7%BD%91frps.png"></p>
<p>其中，bind_port就是先前在阿里云上开放的用于frp运行时占用的端口，此处设置为7007。</p>
<h1 id="4-FRP客户端"><a href="#4-FRP客户端" class="headerlink" title="4 FRP客户端"></a>4 FRP客户端</h1><p>由于人没在学校用不了校园网，而同学之前已经做过一个端口的内网穿透，所以先借助这个跳板连上实验室机器。其中，7788是他们已经成功内网穿透的一个端口，公网服务器IP是已经成功内网穿透的公网服务器IP。所以，先ssh连上内网机器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -p 7788 实验室机器用户名@公网服务器IP</span><br></pre></td></tr></table></figure>

<p>同样，在内网端下载FRP并解压，此处下载0.36.1版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.36.1&#x2F;frp_0.36.1_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf frp_0.36.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>因为<strong>内网机器充当frp客户端</strong>，所以只留下以下两个文件即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frpc   frpc.ini</span><br></pre></td></tr></table></figure>

<p>修改frpc.ini配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/%E5%86%85%E7%BD%91frpc.png"></p>
<p>其中：</p>
<ol>
<li>server_addr为<strong>阿里云公网服务器IP</strong>；</li>
<li>server_port为先前在阿里云上开放的用于frp运行时占用的端口，即需要和frps.ini中的bind_port对齐，此处设置为7007；</li>
<li>remote_port为先前在阿里云上开放的用于访问内网机器的端口，此处设置为7777。</li>
</ol>
<h1 id="5-后台运行FRP"><a href="#5-后台运行FRP" class="headerlink" title="5 后台运行FRP"></a>5 后台运行FRP</h1><h2 id="5-1-公网服务器端"><a href="#5-1-公网服务器端" class="headerlink" title="5.1 公网服务器端"></a>5.1 公网服务器端</h2><p>首先，在<strong>公网服务器端后台运行frps</strong>。目录定位到当前frp文件夹，在命令行中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup .&#x2F;frps -c .&#x2F;frps.ini &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>输入<code>jobs</code>命令，若看到进程状态是Running，则表示frps进程运行成功。</p>
<h2 id="5-2-内网机器端"><a href="#5-2-内网机器端" class="headerlink" title="5.2 内网机器端"></a>5.2 内网机器端</h2><p>其次，在<strong>内网机器端后台运行frpc</strong>。目录定位到当前frp文件夹，在命令行中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup .&#x2F;frpc -c .&#x2F;frpc.ini &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>输入<code>jobs</code>命令，若看到进程状态是Running，则表示frpc进程运行成功。</p>
<h1 id="6-访问内网"><a href="#6-访问内网" class="headerlink" title="6 访问内网"></a>6 访问内网</h1><p>最后一步，通过外网机器访问内网机器。在<strong>本地</strong>命令行窗口输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -p 7777 实验室机器用户名@47.106.232.139</span><br></pre></td></tr></table></figure>

<p>不出意外的话，输入密码就连接成功啦。</p>
<p>之后如果想要免密登录的话，就和第2节的操作类似，区别就是ssh的时候记得加上<code>-p 端口号</code>，scp的时候记得加上<code>-P 端口号</code>即可。</p>
<h1 id="7-传输文件"><a href="#7-传输文件" class="headerlink" title="7 传输文件"></a>7 传输文件</h1><h2 id="7-1-从服务器下载文件至本地"><a href="#7-1-从服务器下载文件至本地" class="headerlink" title="7.1 从服务器下载文件至本地"></a>7.1 从服务器下载文件至本地</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -P 7777 实验室机器用户名@47.106.232.139:文件绝对路径 本地存放目录路径</span><br></pre></td></tr></table></figure>

<h2 id="7-2-从本地上传文件至服务器"><a href="#7-2-从本地上传文件至服务器" class="headerlink" title="7.2 从本地上传文件至服务器"></a>7.2 从本地上传文件至服务器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -P 7777 本地文件路径 实验室机器用户名@47.106.232.139:存放目录绝对路径 </span><br></pre></td></tr></table></figure>

<h2 id="7-3-细节"><a href="#7-3-细节" class="headerlink" title="7.3 细节"></a>7.3 细节</h2><ol>
<li><code>scp</code>命令中指定端口号用的是<code>-P</code>参数(P大写)，<code>ssh</code>建立远程连接命令中指定端口号用的是<code>-p</code>参数(p小写)；</li>
<li>如果传输的是文件夹，就加<code>-r</code>参数。</li>
</ol>
<h1 id="8-过程中遇到的问题"><a href="#8-过程中遇到的问题" class="headerlink" title="8 过程中遇到的问题"></a>8 过程中遇到的问题</h1><h2 id="8-1-防火墙"><a href="#8-1-防火墙" class="headerlink" title="8.1 防火墙"></a>8.1 防火墙</h2><p>在公网服务器端运行frps，报no route to host的错误。这种错误是由于公网服务器端的防火墙没有关闭引起的。因此，在公网服务器端输入以下命令：</p>
<p>查看防火墙状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure>

<p>停止防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>

<p>禁止firewall开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld.service </span><br></pre></td></tr></table></figure>

<p>问题解决。</p>
<h2 id="8-2-端口占用"><a href="#8-2-端口占用" class="headerlink" title="8.2 端口占用"></a>8.2 端口占用</h2><p>由于一开始不太懂得怎么操作，所以有时候会把某一个端口开了之后，又在相同的端口上运行了其他进程，故会报Error starting userland proxy: listen tcp 0.0.0.0:xxxx: bind: address already in use的错误。这种情况下，需要先查看当前机器的端口占用情况，然后把端口进程杀死即可。</p>
<p>查看端口占用情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -tanlp</span><br></pre></td></tr></table></figure>

<p>查看到需要停止的端口进程PID后，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill PID</span><br></pre></td></tr></table></figure>

<p>即可将该端口处的进程停止。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/cao0507/article/details/82758288">阿里云服务器实现frp内网穿透</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/45445979">frp实现内网穿透</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/347239470?utm_source=wechat_session&utm_medium=social&utm_oi=939179790134165504">在外如何访问内网？—— FRP内网穿透</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>FRP</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞/非阻塞/同步/异步/回调机制</title>
    <url>/post/6a12d2c0.html</url>
    <content><![CDATA[<p>I/O通信里的阻塞/非阻塞/同步/异步/回调机制通俗理解</p>
<a id="more"></a>

<h2 id="1-同步-amp-异步"><a href="#1-同步-amp-异步" class="headerlink" title="1 同步&amp;异步"></a>1 同步&amp;异步</h2><p>同步，还是异步，是从”消息通信”的视角去描述这个接口的行为。而所谓的消息通信，你可以简单的把”函数”想象成一个淘宝客服，把”调用方”想象成你自己。调用函数的过程其实就是三步：</p>
<ol>
<li>“你”询问”淘宝客服”一个问题。比如，”在吗？”。在这个场景中，你就是”调用方”，”淘宝客服”是函数，而那句”在吗？”，则是函数参数，你把函数参数传递给函数；</li>
<li>“淘宝客服”进行后台处理。这时淘宝客服接收到了你的询问消息，如果他没有在忙，那么他可以立即回复你。如果他现在正在忙，比如淘宝客服需要先看一下你之前的行为记录，然后再决定如何回复你。(比如他看到你正在浏览一双袜子，觉得你是潜在的买家，他决定回复你。比如他看到你三天前下单买了一双袜子，但袜子还没有发货，他觉得你有退货的风险，从而决定不理你，假装不在。) 这个客服思考决断的过程，就是函数内部进行处理运算的过程；</li>
<li>最终，淘宝客服回复了你，”在的，亲”。这里，回复这个动作，就是函数返回，而”在的，亲”这句话，就是函数的返回值。</li>
</ol>
<p>你从这个角度去看，函数调用，就是消息通信的过程，你发送消息给函数，函数经过一番运算思考，把结果再回发给你。</p>
<p>所谓的<em>同步、异步</em>，指的是：</p>
<ol>
<li>这个淘宝客服很老实，对于每个顾客发来的问题，他都需要经过一番思考，再进行答复。这个函数很老实，对于每个函数调用，都很老实的根据传入参数进行计算，再返回结果。也是是说，在淘宝客服思考结束之前，这个客服不会向你发送答复，你也收不到答复。也就是说，在函数运算结束之前，函数不会返回，你也得不到返回值。那么，这个客服是<em>同步</em>的，这个函数调用的过程是<em>同步调用</em>，这个函数是<em>同步</em>的；</li>
<li>假如这个淘宝客服很不老实，他装了一个自动答复小程序。对于每个询问的顾客，都先自动回复一句”亲，现在很忙哟，客服MM可能过一会才能给你答复”。也就是说，顾客在发出询问之后，立即就能得到一个答复。也就是说，调用方在调用一个函数之后，这个函数就立即返回了。而真正的结果，可能在过五分钟之后才会给你。即是五分钟之后客服对你说”在的呢，亲”。这样的函数，就叫<em>异步函数</em>。</li>
</ol>
<p>异步客服需要解决一个问题：当真正的运算结果得出之后，被调用的客服如何通知作为调用方的你，取走答案。在淘宝客户端上，是通过手机的震动消息提醒，是通过聊天框的红点。</p>
<p>所以，关于同步，和异步，这里做一个稍微正式一点的总结：</p>
<ol>
<li>同步的过程：调用方传参-&gt;函数运算-&gt;函数返回运算结果；</li>
<li>异步的过程：调用方传参-&gt;函数说我知道了-&gt;然后过了五分钟，函数说我算出来了，结果在这里，你来取。</li>
</ol>
<p>这里我们着眼于消息的传递，通讯方式，也就是站在函数的角度去看，结果是如何传递给调用方的。同步接口，运算结果在”函数调用”这个场景下就返回给了调用方。异步接口：运算结果在”函数调用”这个场景之后的<strong>某个不定的时刻</strong>，通过<em>某种通知方式</em>，传递给调用方。</p>
<h2 id="2-阻塞-amp-非阻塞"><a href="#2-阻塞-amp-非阻塞" class="headerlink" title="2 阻塞&amp;非阻塞"></a>2 阻塞&amp;非阻塞</h2><p>整个过程中我们忽略了一件事：就是，在函数执行运算的过程中，调用方在干什么。也是是，在淘宝客服内心思考如何回复你的时候，你在干什么。</p>
<p>这就引出了阻塞与非阻塞：</p>
<ol>
<li>阻塞：在函数执行运算的过程中，当前线程什么也做不了。在等待客服回复的过程中，你什么也不做，就在那干等着，直到他回复了你；</li>
<li>非阻塞：在函数执行的过程中，当前线程可以去做其它事情。在等待客服回复的过程中，你上了个厕所，还顺便洗了个澡。</li>
</ol>
<p>换句话说：</p>
<ol>
<li>同步与异步，描述的是 <em>被调用的函数</em>，如何将结果返回给调用者；</li>
<li>阻塞与非阻塞，描述的是 <em>调用方</em>，在得到结果之前能不能脱身。</li>
</ol>
<p>这是两个维度上的逻辑概念，这两个维度互相有一定的干涉，并不是完全正交的两个维度，这样，既然是两个维度，那么就有四种组合：</p>
<ol>
<li>同步，且阻塞：调用方发起调用直至得到结果之前，都不能干其它事情。被调函数接收到参数直到运算结束之前，都不会返回；</li>
<li>同步，非阻塞：调用方发起调用直至得到结果之前这段时间，可以做其它事情。但被调函数接收到参数直到运算结束之前，都不会返回。很显然这个逻辑概念说得通，但其实是反常理的。因为：如果调用方在发起调用之后，得到结果(函数返回)之前，要去做其它事情，那么就有一个隐含的前提条件：调用方必须知道本次调用的耗时，且被调方(函数)严格遵守这个时间约定。一毫秒不多，一毫秒不少。这在代码的世界里是很难达到的；</li>
<li>异步，且阻塞：调用方发起调用直至得到结果之前，都不能干其它事情。被调用函数接收到参数之后立即返回，但在随后的某个时间点才把运算结果传递给调用方。之后调用方继续活动。这个逻辑概念依然说得通，但是很别扭。这就相当于，在你问淘宝客服问题的时候，淘宝客服的自动回复机器人已经给你说了”客服很忙哟，可能过一会才能答复你”，但你就是啥也不干，非得等到客服答复你之后，才去上厕所。这种情景在代码世界里可能发生，但似乎很智障；</li>
<li>异步，非阻塞：调用方发起调用直至得到结果之前这段时间，可以做其它事情。被调函数接收到参数后立即返回，但在之后的某一个时间点才把运算结果传递给调用方。这说起来很绕口，举个栗子，还是客服：<ol>
<li>你拿出手机，向客服发送消息，”在吗？”。然后把手机放桌子上，转向上厕所去了；</li>
<li>客服收到你的消息，机器人回复你”不好意思，客服现在很忙，但我们会尽快答复你的，亲！”；</li>
<li>你上厕所回来了，看手机没消息，又去吃饭了；</li>
<li>客服开始处理你的消息，终于开始给你真正的回复”亲，2333号客服为您服务，你有什么要了解的吗？”；</li>
<li>你吃饭的过程中，手机震动，你点开淘宝，发现有了回复。整个流程结束。</li>
</ol>
</li>
</ol>
<p>可以看到：</p>
<ol>
<li>阻塞方式下，调用方总是能第一时间拿到调用结果。因为在阻塞期间，调用方啥也不干，就等着函数返回结果。非阻塞方式下，调用方一般都是在函数返回了结果之后才去查看运算结果；</li>
<li>异步方式下，被调用方可以推迟处理任务。客服收到你的消息后可以先把饭吃完，函数收到你的调用后并不一定立即就开始运算；</li>
<li>同步且阻塞，双方都是老实人；</li>
<li>异步非阻塞，调用方不在乎什么时候能得到运算结果，被调用方不在乎调用方着急不着急。调用方佛系，被调用方精明。</li>
</ol>
<h2 id="3-回调函数"><a href="#3-回调函数" class="headerlink" title="3 回调函数"></a>3 回调函数</h2><p>在上面讲过，异步调用，需要函数以某种机制，在运算结果得出之后，将运算结果传递给调用方。</p>
<p>假设没有回调函数机制，异步流程就是：</p>
<ol>
<li>顾客询问客服，”你们家有没有AMD的显卡啊？我想给我弟弟买一个”。然后去上厕所去了；</li>
<li>自动机器人向顾客回复”很忙哟，请耐心等待”；</li>
<li>客服开始处理顾客的询问，去库房查货；</li>
<li>库房有货，客服要想办法将这个信息送到顾客手中。他通过淘宝客户端发表了答复，淘宝客户端导致手机震动，这个震动信号通知了顾客；</li>
<li>顾客正在上厕所，看到手机上的消息提醒，思考了一分钟，顾客下单购买了这个显卡。</li>
</ol>
<p>这个流程里顾客做了两件事：</p>
<ol>
<li>询问客服”有没有AMD的显卡”。这是调用函数的行为；</li>
<li>在得到肯定的答复之后，下单购买了这个显卡。这是得到函数返回的运算结果，并根据运算结果进一步执行程序流程(调用了另外一个函数：购买)。</li>
</ol>
<p>而淘宝客服只做了一件事：</p>
<ol>
<li>查询库房里是否有货。</li>
</ol>
<p>而有了回调机制后，异步流程就是这样的：</p>
<ol>
<li>顾客询问客服，”你们家有没有AMD的显卡？”。然后顾客把手机交给秘书，叮嘱道：”你盯着这个客服，如果他说有，你就下单买了，地址写我家，如果没有，你就啥也不做”。然后顾客坐上了出差的飞机；</li>
<li>自动机器人向顾客回复”很忙哟，请耐心等待”；</li>
<li>客服开始处理顾客的询问，去库房查货；</li>
<li>库房有货，客服要想办法将这个信息送到顾客手中。他通过淘宝客户端发表了答复，淘宝客户端导致手机震动，这个震动信号通知了秘书；</li>
<li>秘书根据老板的指示，下单购买了这个显卡。</li>
</ol>
<p>这个流程里，顾客做了两件事：</p>
<ol>
<li>询问客服”有没有AMD的显卡”。这是调用函数行为；</li>
<li>向秘书叮嘱。这是向消息监控方注册回调函数的行为。消息监控方负责接收函数的返回结果。回调函数则是：”如果有，就买给老板弟弟，如果没有，就什么也不做”。</li>
</ol>
<p>淘宝客服只做了一件事：</p>
<ol>
<li>查询库房里是否有货。</li>
</ol>
<p>而消息监控方，也就是秘书，做了一件事：</p>
<ol>
<li>根据客服的答复选择不同的行为。即在函数调用结果得出之后，调用回调函数。</li>
</ol>
<p>这就是回调函数的一个生动的例子，回调函数机制中有了一个<em>调用结果监控方</em>，就是秘书，这个角色承担着非常重要的职责：即是在函数返回结果之后，调用对应的回调函数。回调机制一般都实现在异步调用框架之中，对于写代码的人来说是透明的，它简化了调用方的职责与智力负担，一定程度上抽象了代码逻辑，简化了编程模型(注意：是一定程度上)。有了回调机制：</p>
<ol>
<li>调用方不必再去关心函数返回结果以及返回时机。不必通过轮询或其它方式去检查异步函数是否返回了结果；</li>
<li>调用方在调用时就向<em>调用结果监控方</em>注册合适的回调，在调用函数那一刻，将后续业务逻辑写在回调函数中，只负责调用就行了。代码越写越像状态机。</li>
</ol>
<h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4 参考链接"></a>4 参考链接</h2><p><a href="https://blog.csdn.net/weixin_30410999/article/details/99426922">https://blog.csdn.net/weixin_30410999/article/details/99426922</a></p>
]]></content>
      <categories>
        <category>Operation System</category>
      </categories>
      <tags>
        <tag>I/O Communication</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-天池-GAIIC-赛道一-记录</title>
    <url>/post/c516f0e3.html</url>
    <content><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><p>第一次参赛，意义特殊，记录一下。</p>
<p>比赛链接：<a href="https://tianchi.aliyun.com/competition/entrance/531852/introduction?lang=zh-cn">https://tianchi.aliyun.com/competition/entrance/531852/introduction?lang=zh-cn</a></p>
<p>完整代码：<a href="https://github.com/YihaoChan/2021-Tianchi-GAIIC-Track1-Rank-3">https://github.com/YihaoChan/2021-Tianchi-GAIIC-Track1-Rank-3</a></p>
<a id="more"></a>

<p><img data-src="/images/2021-%E5%A4%A9%E6%B1%A0-GAIIC-%E8%B5%9B%E9%81%93%E4%B8%80-%E8%AE%B0%E5%BD%95/%E8%AF%81%E4%B9%A6.jpg"></p>
<p><img data-src="/images/2021-%E5%A4%A9%E6%B1%A0-GAIIC-%E8%B5%9B%E9%81%93%E4%B8%80-%E8%AE%B0%E5%BD%95/%E5%A5%96%E6%9D%AF.jpg"></p>
<h1 id="1-赛题介绍"><a href="#1-赛题介绍" class="headerlink" title="1 赛题介绍"></a>1 赛题介绍</h1><ul>
<li><p>提供：CT影像描述<strong>文本</strong>；</p>
</li>
<li><p>样例：右下肺野见小结节样影与软组织肿块影 =&gt; 患病区域：右下肺野，诊断类型：小结节样影与软组织肿块影；</p>
</li>
<li><p>需求：判断身体若干目标区域是否有异常以及异常类型.</p>
</li>
</ul>
<p>从”若干”可判断出任务属于<strong>多标签</strong>任务，从”区域是否有异常”及”异常类型”可以考虑将不同区域和不同类型做<strong>One-Hot编码</strong>，之后进行<strong>0/1的二分类</strong>。简而言之，赛题属于NLP中的NLU自然语言理解领域下的多标签二分类问题。</p>
<h1 id="2-数据样例"><a href="#2-数据样例" class="headerlink" title="2 数据样例"></a>2 数据样例</h1><table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">类型</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">report_ID</td>
<td align="center">int</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">description</td>
<td align="center">文本，<strong>脱敏</strong></td>
<td align="center">101 47 12 66 74 90 0 411 234 79</td>
</tr>
<tr>
<td align="center">label</td>
<td align="center">区域<strong>ID</strong>，类型<strong>ID</strong></td>
<td align="center">3 4, 0 2</td>
</tr>
</tbody></table>
<p>数据没有任何明文，都是对中文进行加密后的数字，属于无明文<strong>脱敏</strong>数据。由此判断，无法直接调用任何已经开源的预训练权重做下游任务，如果要采用预训练模型的话，需要从头训练(<strong>Train from scratch</strong>)。</p>
<h1 id="3-数据探索与分析-EDA-Exploratory-Data-Analysis"><a href="#3-数据探索与分析-EDA-Exploratory-Data-Analysis" class="headerlink" title="3 数据探索与分析(EDA, Exploratory Data Analysis)"></a>3 数据探索与分析(EDA, Exploratory Data Analysis)</h1><h2 id="3-1-data分布"><a href="#3-1-data分布" class="headerlink" title="3.1 data分布"></a>3.1 data分布</h2><p>对训练集和A榜测试集的description字段数据用PCA降至二维并可视化分布图后，如图：</p>
<p><img data-src="/images/2021-%E5%A4%A9%E6%B1%A0-GAIIC-%E8%B5%9B%E9%81%93%E4%B8%80-%E8%AE%B0%E5%BD%95/distribution_train.jpg"></p>
<p><img data-src="/images/2021-%E5%A4%A9%E6%B1%A0-GAIIC-%E8%B5%9B%E9%81%93%E4%B8%80-%E8%AE%B0%E5%BD%95/distribution_test_a.jpg"></p>
<p>训练集和A榜测试集的data满足同分布。</p>
<h2 id="3-2-句长分布"><a href="#3-2-句长分布" class="headerlink" title="3.2 句长分布"></a>3.2 句长分布</h2><p>统计训练集和A榜测试集中不同句长所对应的description数量，如图：</p>
<p><img data-src="/images/2021-%E5%A4%A9%E6%B1%A0-GAIIC-%E8%B5%9B%E9%81%93%E4%B8%80-%E8%AE%B0%E5%BD%95/seq_len_train_set.jpg"></p>
<p><img data-src="/images/2021-%E5%A4%A9%E6%B1%A0-GAIIC-%E8%B5%9B%E9%81%93%E4%B8%80-%E8%AE%B0%E5%BD%95/seq_len_test_set_a.jpg"></p>
<p>训练集和A榜测试集上，最短句长均为4，最长句长分别为104和102，做句长截断、填充的时候可以参考。</p>
<h2 id="3-3-词频统计"><a href="#3-3-词频统计" class="headerlink" title="3.3 词频统计"></a>3.3 词频统计</h2><p>对训练集和A榜测试集的description字段数据进行词频统计：</p>
<p>训练集和A榜测试集上，编码均从0 ~ 857，词典大小均为858。词频的top2所对应的词相同，均为693、328，结合以往阅读文章的经验，可猜想这两个数字对应中文明文的逗号和句号。这也是后续我们的方案中，<strong>去除停用词</strong>的依据。</p>
<p>PS. 去除停用词相关：</p>
<ol>
<li>“在构建主题模型的过程中，我们会发现’的’’地’’得’这样的词语无助于表达一个主题。由于这样的词语实在是太多了，在主题的词语分布中占有重要位置，导致我们总结一个主题的含义时遇到很大的困难。这个时候，去掉这些价值不大、有负作用的词语成为必需。”；</li>
<li>“任何使用词袋模型表示文本数据的场景，都必须考虑是否需要去除停用词。这几年，我们经常使用字粒度的语言模型，比如BERT、GPT来做NLP任务。这类模型需要把句子中所有的成分都考虑进来，从而更加精准地刻画语言规律。”</li>
</ol>
<h1 id="4-模型"><a href="#4-模型" class="headerlink" title="4 模型"></a>4 模型</h1><h2 id="4-1-初赛"><a href="#4-1-初赛" class="headerlink" title="4.1 初赛"></a>4.1 初赛</h2><p>初赛我们最后融合的模型有：NEZHA、LSTM、HAN、DPCNN。</p>
<p>灵机一动，参考NEZHA名字的由来：</p>
<p><strong>NEZHA: <em>NE</em>ural contextuali<em>Z</em>ed representation for C<em>H</em>inese l<em>A</em>nguage understanding</strong></p>
<p>我也想了一个单词，组合我们所用的这些模型：</p>
<p><strong>Normandy: <em>N</em>EZHA, L<em>O</em>ng Sho<em>R</em>t-Term <em>M</em>emory, Hierarchical <em>A</em>ttention <em>N</em>etworks and <em>D</em>eep P<em>Y</em>ramid Convolutional Neural Networks</strong></p>
<p>主要流程：</p>
<ol>
<li>对于NEZHA预训练模型：将训练集和测试集的description进行”一句一文档”的操作进行预训练，之所以进行”一句一文档”，是为了取消BERT模型的NSP(Next Sentence Prediction)任务，因为NSP任务在BERT类模型上表现都不好，这一点已在RoBERTa论文中有提到。单进行MLM任务之后，调用预训练权重接全连接层生成回归概率，进入微调训练阶段，结合FGM对抗训练和Warm Up + 余弦退火调整学习率；</li>
<li>对于基础深度学习模型(LSTM、HAN、DPCNN)：先去除停用词(693、328)，然后使用Warm Up + 余弦退火进行学习率调整；</li>
<li>两类模型均使用分层采样与k折交叉验证；</li>
<li>最后将两部分结果进行加权融合，单模得分较高者获得更大的权重。</li>
</ol>
<p>单模结果与融合后结果用t-SNE降至三维并可视化后，如图：</p>
<p><img data-src="/images/2021-%E5%A4%A9%E6%B1%A0-GAIIC-%E8%B5%9B%E9%81%93%E4%B8%80-%E8%AE%B0%E5%BD%95/3D_results_lstm.jpg"></p>
<p><img data-src="/images/2021-%E5%A4%A9%E6%B1%A0-GAIIC-%E8%B5%9B%E9%81%93%E4%B8%80-%E8%AE%B0%E5%BD%95/3D_results_han.jpg"></p>
<p><img data-src="/images/2021-%E5%A4%A9%E6%B1%A0-GAIIC-%E8%B5%9B%E9%81%93%E4%B8%80-%E8%AE%B0%E5%BD%95/3D_results_dpcnn.jpg"></p>
<p><img data-src="/images/2021-%E5%A4%A9%E6%B1%A0-GAIIC-%E8%B5%9B%E9%81%93%E4%B8%80-%E8%AE%B0%E5%BD%95/3D_results_nezha.jpg"></p>
<p><img data-src="/images/2021-%E5%A4%A9%E6%B1%A0-GAIIC-%E8%B5%9B%E9%81%93%E4%B8%80-%E8%AE%B0%E5%BD%95/3D_results_merge.jpg"></p>
<p>直观上粗略看一下，集成之后的结果”综合”了多个单模的结果，不会让部分数据太过极端，同时也有照顾到多方面的结果分布，体现出了模型融合的思想：”采纳多方意见”。</p>
<h2 id="4-2-复赛"><a href="#4-2-复赛" class="headerlink" title="4.2 复赛"></a>4.2 复赛</h2><p>同初赛，复赛我们所采用的模型的名字为：</p>
<p><strong>Noah’s Ark: <em>N</em>EZHA Trained J<em>O</em>intly and Sep<em>A</em>rately with <em>H</em>AN, L<em>S</em>TM and Deep Pyr<em>A</em>mid Convolutional Neu<em>R</em>al Networ<em>K</em>s</strong></p>
<p>主要流程：</p>
<ol>
<li><p>对于NEZHA预训练模型：预训练阶段取消NSP任务，微调训练阶段采用<strong>联合训练</strong>(Jointly Train)与<strong>分开训练</strong>(Separately Train)两种策略，即：</p>
<ol>
<li>联合训练：将两个任务拼接作为一个完整任务进行训练；</li>
<li>分开训练：将任务1和任务2分别用不同模型训练，之后再将结果进行拼接。恰好，初赛与复赛的任务1相同，因此可以将初赛的训练集一起加入，与复赛的训练集一起训练任务1，数据量得以提升。</li>
</ol>
<p>在使用相同超参数的情况下，实验结果表明，在这个数据集中，分开训练不仅能提升总得分，还能缩小两个任务之间的得分差距：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>任务1得分</th>
<th>任务2得分</th>
<th>总得分</th>
<th>任务gap</th>
</tr>
</thead>
<tbody><tr>
<td>联合训练</td>
<td>0.9257</td>
<td>0.9142</td>
<td>0.9212</td>
<td>0.0115</td>
</tr>
<tr>
<td>分开训练</td>
<td>0.9326</td>
<td>0.9302</td>
<td>0.9316</td>
<td>0.0024</td>
</tr>
</tbody></table>
<p>因为NEZHA单模表现实在太优秀，所以两种策略都做，之后再融合。训练阶段结合FGM对抗训练和Warm Up + 余弦退火调整学习率；</p>
</li>
<li><p>对于基础深度学习模型(LSTM、HAN、DPCNN)：采用分开训练的策略，训练过程中，先去除停用词(693、328)，然后使用Warm Up + 余弦退火进行学习率调整；</p>
</li>
<li><p>两类模型均使用分层采样与k折交叉验证；</p>
</li>
<li><p>最后将两部分结果进行加权融合，单模得分较高者获得更大的权重。</p>
</li>
</ol>
<p>复赛的测试集和提交结果等均在线上不可下载、不可打印，所以无可视化图。</p>
<h1 id="5-其余尝试"><a href="#5-其余尝试" class="headerlink" title="5 其余尝试"></a>5 其余尝试</h1><ol>
<li>伪标签：第一次先用原训练集进行训练后，对测试集做推理，得出初步推理结果。之后将推理得到的output和测试集的data拼接成新的训练数据加入训练集，再对这个新的训练集进行训练，最后对测试集再做一次推理，得到提交结果。不过这个方案在我们的模型上表现不好，同时运行时间也长了很多；</li>
<li>数据增强：随机交换句中的任意两个词、随机删除句中的部分词、将整个句子分为多段并打乱顺序。掉分原因可能是简单数据增强(EDA,  Easy Data Augmentation)所增强获得的数据质量不够高，增强后的数据分布可能破坏了原数据集的分布。同时，EDA有可能在增强的过程中，改变了句子的意思，但其仍保留原始的类别标签，从而产生了标签错误的句子；</li>
<li>对损失函数手动分配权重：由于标签类别不平衡，最多的类别所对应数据数量有1846，最少的只有209，属于类别不平衡问题。因此考虑在训练的时候给损失函数直接设定一定的比例，比例大小和标签数量成反比，使得算法能够对小类数据具有更多的”注意力”，即<strong>对长尾数据做重加权re-weighting</strong>。初赛时我做了这个尝试，不过效果不好。猜想：标签类别是否已经不平衡到需要手动分配权重的程度？也就是说，在这种情况下，手动分配权重是否有必要？；</li>
<li>拼接Word2Vec和GloVe词向量做Embedding层的初始化：对于基础深度学习模型，先用Word2Vec和GloVe分别做词向量预训练，然后将这两部分词向量进行拼接，初始化Embedding层，不冻结权重，在训练过程中继续学习。可能的掉分原因：<ol>
<li>词向量的解释性太差；</li>
<li>对于CBOW模型，在训练阶段中心词的词向量是把窗口大小内上下文的词向量相加作为输入，显然这忽略了文本的序列信息；</li>
<li>无法获得文本的情感信息，例如”好”、”坏”这两个词其使用的语境基本相同，训练出的这两个词向量会十分相似，但是其表示的情感意思却完全相反。要获得情感信息需要大量标注好的语料，需要包含不同情感得分的每个词的句子作为训练语料以获得这个词的词向量，这需要大量的相关语料；</li>
<li>最主要的问题是无法获得语境信息，从而无法解决一词多义的问题。因为通过Word2Vec所训练出的词向量是静态的，对于一个词无论其所处的语言环境如何最终都用相同的词向量表示。</li>
</ol>
</li>
<li>分组构造NSP任务：对于标签相同的description，将它们拼接成同一个文档，构造出一个文档中有多个句子的状况，以加入预训练过程中的NSP任务。掉分的可能原因之一已在前面简述：BERT的NSP任务本身表现不是很好。当然，也可能是因为这样分组的操作本身存在问题；</li>
<li>加载开源权重：尝试过在预训练的时候，用华为已经训练好了的权重做初始化(除Embedding层外，其余层的信息仍然有价值)，发现与不加载权重相比，线上得分相差非常小，还不排除是云平台不同机器的原因。考虑到加载权重需要额外空间，所以最后仍然采取全代码运行、不加载权重的方案。</li>
</ol>
<h1 id="6-量化指标"><a href="#6-量化指标" class="headerlink" title="6 量化指标"></a>6 量化指标</h1><ol>
<li>训练时间：Tesla V100单卡，全流程运行约42小时；</li>
<li>推理速度：Tesla V100单卡，推理速度约320ms/条。</li>
</ol>
<h1 id="7-值得借鉴的方案"><a href="#7-值得借鉴的方案" class="headerlink" title="7 值得借鉴的方案"></a>7 值得借鉴的方案</h1><h2 id="7-1-预训练"><a href="#7-1-预训练" class="headerlink" title="7.1 预训练"></a>7.1 预训练</h2><ol>
<li><p>加载开源的WWM(Whole Word Masking)全词掩码权重；</p>
</li>
<li><p>MLM任务使用N-gram Masking[参考ALBERT]；</p>
</li>
<li><p>MLM任务使用Dynamic Masking[参考RoBERTa]；</p>
</li>
<li><p>将训练集的data和label拼接在一起作为新的一整条文本，即：把标签也加进去预训练，因为标签本身也自带语义；</p>
</li>
<li><p>引入SBO(Span-Boundary Objective)任务[参考SpanBERT]；</p>
</li>
<li><p>引入SOP(Sentence-Order Prediction)任务[参考ALBERT]；</p>
</li>
<li><p>尝试通过对齐词频的方式找出分句符，制造NSP任务的语料，否则不能构造出真正的NSP任务；</p>
</li>
<li><p>多任务联合训练[参考MT-DNN]；</p>
</li>
<li><p>持续学习：[ERNIE 2.0]提出了<strong>持续学习</strong>的概念，防止学习不同任务时产生灾难性遗忘。当进行多任务预训练时：</p>
<ol>
<li>先在任务1上预训练；</li>
<li>然后使用上一步的参数对模型进行初始化，并对任务1和任务2同时预训练；</li>
<li>再使用之前的参数对模型进行初始化，并对任务1、任务2和任务3同时预训练；</li>
<li>以此类推。</li>
</ol>
<p>第四名的队伍基于这个思想采取了以下策略：首先将任务2的标签加入文本进行预训练，之后加载上一步的权重，将任务1和任务2的标签一起加入，做<strong>联合预训练</strong>。</p>
</li>
</ol>
<h2 id="7-2-微调"><a href="#7-2-微调" class="headerlink" title="7.2 微调"></a>7.2 微调</h2><ol>
<li><p>交替训练：[Don’t Stop Pretraining]一文指出，要做领域自适应(DAPT, domain-adaptive pretraining)和任务自适应(TAPT, task-adaptive pretraining)的预训练。第一名的队伍基于这个思想采取了以下策略：交替训练任务1和任务2满足<strong>任务自适应</strong>的定义，因此，首先用任务1对预训练权重进行微调，之后将任务1的微调权重用于微调任务2，再反过来微调任务1，最终再微调任务2；</p>
</li>
<li><p>Lookahead；</p>
</li>
<li><p>SWA(Stochastic Weight Averaging，随机权重平均)。</p>
</li>
</ol>
<h1 id="8-个人心路历程"><a href="#8-个人心路历程" class="headerlink" title="8 个人心路历程"></a>8 个人心路历程</h1><h2 id="8-1-参赛前"><a href="#8-1-参赛前" class="headerlink" title="8.1 参赛前"></a>8.1 参赛前</h2><p>二月末的时候，同班同学zyp发给了我有关这个比赛的链接，还是我们学校计算机学院公众号推送的。当时只看题目的时候，还觉得赛道一可能是数据挖掘类的题(做特征工程的那种)，赛道二明显是CV(不喜欢CV，直接跳过这个题)，赛道三是文本语义匹配，妥妥的NLP，而且肯定BERT当道的类型，当时还完全不了解BERT，只知道个名字…那个时候其实也没什么忙的事情做，而且以后也想往机器学习方面发展，总是要尝试第一次的嘛，看上去赛道一比较适合新手一点，所以就拉上之前做课程项目的固定队友lrx同学，一起决定报名赛道一了。</p>
<h2 id="8-2-初赛"><a href="#8-2-初赛" class="headerlink" title="8.2 初赛"></a>8.2 初赛</h2><h3 id="8-2-1-尝试"><a href="#8-2-1-尝试" class="headerlink" title="8.2.1 尝试"></a>8.2.1 尝试</h3><p>一开始一公布数据集和题目的时候，就开始自己动手实现了，仔细理解了一下题目，发现就是NLP的题。好在之前接触过一点NLP方面的东西，就对照着之前自己做的一些小demo，修修补补，抄抄删删，勉强做出来的baseline真是速度又慢、效果又差…一直很郁闷的时候，群里一位西交自动化的研究生师兄公布了他的baseline。当时跑通baseline之后，明显比我的成绩好得不要太多，就决定拿他的baseline来改了。其实后来才知道，一些热门的比赛中，会有一些选手公布自己的baseline给其他选手，算是一种分享。不过自己也不能太依赖别人的东西，是吧~</p>
<p>看懂baseline，然后封装、优化，形成自己的代码风格后，就开始改模型、调参了。期间多亏了zyp同学在他们实验室的服务器上(偷偷)给我开了个账号，让我连进去炼丹，具体过程见这篇博客：<a href="https://yihaochan.github.io/post/cb736208.html">记一次内网穿透</a>。把baseline的CNN换上自己中意的双向LSTM之后，一度冲上30名，然后就瓶颈了…好在天池设立了一个”周周星”环节——鼓励每周的排行榜前两名分享自己的方案和心得给其他选手。不得不说这个环节真是太好了，从各位周周星那里真的学到超多比赛的方法和技巧，运用上他们所说的一部分技巧后，我的成绩又有了很大的进步。</p>
<h3 id="8-2-2-结识新队友"><a href="#8-2-2-结识新队友" class="headerlink" title="8.2.2 结识新队友"></a>8.2.2 结识新队友</h3><p>其实蛮可惜的，比赛开始以来zyp同学和lrx同学都有各自的事情要忙，一位忙实验室的论文、忙着做各种实验抽不出时间，一位因为疫情原因不得不放弃出国、转投简历找工作…所以几乎相当于我一直一个人在做比赛，实在蛮累的。记得当时我线上成绩在60名左右就上不去了，刚好群里一位选手的队伍线上40名，二缺一，就缺个调BERT的，而我正好想靠BERT继续冲分(因为传统深度学习模型在NLP的比赛实在太难冲前排了…)，所以就征求了一下两位同学的意见，想过去其他的队伍，毕竟靠自己一个人真的太难太累了，也不想把成绩就此止步。两位队友表示理解之后，我就向招队友的队伍自荐了一下，最后就进入了新队伍啦。</p>
<h3 id="8-2-3-后期"><a href="#8-2-3-后期" class="headerlink" title="8.2.3 后期"></a>8.2.3 后期</h3><p>新队伍的队友是一位学姐和一位师兄。师兄发给了我BERT的keras版本baseline之后，我先花了一天了解了下BERT的原理，然后花了一下午看懂代码后优化，变成自己的风格。之后跑了个裸模型提交了一下，比我之前做的基础深度学习模型加一堆tricks和融合之后的效果好太多太多了…用的是BERT的变种——华为的NEZHA。不得不说，BERT人人都用是有道理的。切B榜之后，把NEZHA和学姐那边基础深度学习模型的结果融了一下，18名，进入复赛。</p>
<h2 id="8-3-复赛"><a href="#8-3-复赛" class="headerlink" title="8.3 复赛"></a>8.3 复赛</h2><h3 id="8-3-1-A榜"><a href="#8-3-1-A榜" class="headerlink" title="8.3.1 A榜"></a>8.3.1 A榜</h3><p>进入复赛后，天池要求提供打包好了的Docker镜像，用线上云平台的机器运行。这一点对我们队来说还是很友好的。我就不说了，本科没机器，硕士还没找老师干活(还在自己补基础和做比赛嘿嘿)；学姐是力学相关专业的，机器学习只是她个人兴趣，所以也没有计算资源；有机器的就师兄那边了，但是有时候一天可能要做好多实验，我这边好几个、师兄那边好几个，只用他的机器实在很麻烦。所以就学了一下Docker，试了下能不能跑通提交后，我们队就都采用线上提交的方式了，刚好测试集在线上不可下载，把代码提交到云端，还能挂载线上的测试集，把文本加进语料库做NEZHA的预训练。挺好的，还多学了Docker这项技能。不得不说一句，天池提供的镜像还蛮难用的，兼容性不是很好…</p>
<p>复赛的label在初赛的基础上增加多了一个任务，我就用NEZHA实现了一下，把两个任务拼接成一个总任务、做One-Hot编码，其余环节不变。当时提交的队伍还蛮少的，我们直接到了前10了，还挺惊喜的。</p>
<p>Well begun is half done. 看到当时的成绩，信心十足。之后进行了蛮多的尝试的：</p>
<ol>
<li>训练策略：这个是最重要的尝试：把两个任务用两个模型分别训练，最后再把推理结果拼接。刚好初赛和复赛的任务1完全一致，所以对于任务1，可以把初赛的训练集也加进来，数据量一下又增加了。一开始还蛮郁闷的，线上一直报OOM(Out of Memory)，明明在脚本入口都释放显存了呀！后来问了下另一个队伍的老哥，建议我两个模型写成两个独立的脚本，真有用，一下就搞定了，名次又往前冲到前5了好像；</li>
<li>固定好NEZHA的折数fold和轮数epoch后，开始加tricks。对抗训练、Warm Up + 余弦退火调整学习率…把NEZHA单模调到了稳定前10，当时前10好多队伍都是用了模型融合才达到的成绩，我们单模就进了前10，所以单模的效果是真的非常好；</li>
<li>然后把NEZHA分开训练和联合训练两个不同策略训练出来的模型的推理结果做加权平均后，又冲上去了好几名；</li>
<li>临近复赛快结束的时候，学姐那边几个基础深度学习模型也调得差不多了，和NEZHA一融，离进决赛的资格(前6)非常非常接近。</li>
</ol>
<h3 id="8-3-2-B榜"><a href="#8-3-2-B榜" class="headerlink" title="8.3.2 B榜"></a>8.3.2 B榜</h3><p>把多个单模的运行时间分别算了一下，得出我们最后一把梭的方案全流程运行大概要42小时。而做代码管理的是我，切B榜之后提交镜像的也是我。B榜有4天的提交时间，而1天只能提交1次，相比较于其他有机器的队伍可以保存权重提交推理部分来说，他们最多可以提交4次，而我们只能提交2次，如果中间报错了，很有可能B榜都出不来成绩…提交的那天早上我心理压力实在太大了，查了很多遍路径、参数，确保万无一失才提交的镜像。提交镜像之后，实在强迫症，反反复复进入镜像又查了五六遍代码，即使查了也没用，交都交了，但是还是真的很不放心…</p>
<p>当然，结局是好的。第一次提交就是我们的最好成绩了，在绝大部分稳进决赛的队伍都提交了成绩之后，我们直接冲到第三。第二次提交就放飞自我了，用了更激进的参数，不过过拟合了哈哈。没事，锁定复赛第三啦！</p>
<h2 id="8-4-决赛"><a href="#8-4-决赛" class="headerlink" title="8.4 决赛"></a>8.4 决赛</h2><p>被通知进入了决赛之后，赶紧开始做PPT。师兄比较有比赛经验，参考往届其他比赛的开源PPT，立马就做出一个框架出来了，之后我在框架上就添加更多细节、更多美化。其实好像初赛的时候哈哈，师兄提供baseline，我做优化。</p>
<p>美化好之后，PPT就发给学姐了，她是主讲人嘛，要根据她的节奏做调整。可以说，我和师兄对PPT做预训练(pretrain)，然后学姐做微调(finetune)，结合BERT哈哈。</p>
<p>准备期间也开了好几次会，做答辩排练，完善一下学姐的答辩过程。我们还准备了很多自问自答，想象自己如果是评委，会对我们的演讲提一些什么问题。</p>
<p>唯一比较遗憾的就是，我们三个人都没能在决赛现场见上面。师兄在实习不让请假，我因为看到广州有一天增加了12例直接吓怕了，不敢乱跑…所以就剩下学姐一人去杭州现场答辩啦，给我们直播会场情况。答辩过程蛮顺利的，评委问的其中一个问题还被我们押中了——“是不是融合越多模型越好？”直接搬出西瓜书的”偏差-方差窘境”，完美！另一个问题也蛮简单的，问预训练后有没有finetune，其实就是问有没有冻结权重嘛，简单。还有之前加了几位其他队伍的选手的微信，他们还夸我们的PPT做得好看~</p>
<p>最终的结果还是蛮安稳的，大家的排名都没有变动，第三，还是很开心滴！</p>
<h2 id="8-5-反思"><a href="#8-5-反思" class="headerlink" title="8.5 反思"></a>8.5 反思</h2><p>这是第一次参加大数据竞赛，真的是远超出自己的预期。最开始我起的队伍名字是：希望能完赛。从一开始抱着重在参与的心态，到后来看到自己一步步在往上爬，再与队友相识，一起冲进复赛、冲进前10、冲进决赛…感觉有些不真实，感觉自己运气很好，遇到的队友是对的，遇到的一起竞赛的选手是乐于分享的，模型选的是没错的，调的参数是准的…当然，也别太得意了，开心一下就可以了，还要学的东西实在很多很多。</p>
<p>想起主办方发给我的采访问题：”能否讲讲指导老师给了你们哪些启发？”一开始我写下的答案只有5个字：”无指导老师”。但是转头一想，每周的前两名周周星会进行方案分享，而我也会在比赛交流群里请教各位前辈，对作为新手的我来说，他们就是我的指导老师。</p>
<p>在知乎看到过非常扎心的一段话：”很多比赛的Leaderboard里大家的分数都相差不大，造成这种现象的原因是已经有好的baseline快接近数据上限了，因此大家的分数都挤在一个小区间里。如果去找一个没有现成baseline的机器视觉比赛看看，就会发现大家的差距其实大得可怕，1000人的比赛，可能第一名accuracy到0.95，第五十名还在0.6动弹不得。”</p>
<p>想想我，不就是这个情况吗？一开始我自己的代码真是一团糟，得亏其他选手开源了baseline，我才能有后续的一系列成绩。还差得远呢！</p>
<p>继续努力。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>Competition</tag>
      </tags>
  </entry>
  <entry>
    <title>God helps those who help themselves.</title>
    <url>/post/4c43581b.html</url>
    <content><![CDATA[<h1 id="陈漪皓同学曲折的申研之路"><a href="#陈漪皓同学曲折的申研之路" class="headerlink" title="陈漪皓同学曲折的申研之路"></a>陈漪皓同学曲折的申研之路</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p style="text-indent:2em">
推免之路终于画上句点啦~三年来，很累，很辛苦，但熬过来之后，一切都变得值得。
</p>

<a id="more"></a>
<p><img data-src="/images/God-helps-those-who-help-themselves/zju/admission.jpg"></p>
<h2 id="大一：漫无目的的努力"><a href="#大一：漫无目的的努力" class="headerlink" title="大一：漫无目的的努力"></a>大一：漫无目的的努力</h2><p style="text-indent:2em">
大一的时候，真的没怎么想，就还是高中思维，觉得把课本读好就行了，所以那时候也是蛮认真的，都在埋头刷分。
</p>
<p style="text-indent:2em">
那时候真的很感谢自己的女神班主任，真的是人生导师！告诉了我读研的重要性，成绩的重要性，大学期间要好好努力的重要性。回过头看，攀硕老师真的是一辈子的好老师！
</p>
<p style="text-indent:2em">
所以大一的时候，成绩还不错，也被选拔进了创新班。
</p>

<h2 id="大二：第一个转折点"><a href="#大二：第一个转折点" class="headerlink" title="大二：第一个转折点"></a>大二：第一个转折点</h2><p style="text-indent:2em">
到了大二上学期，其实有点疲倦了，不知道自己那么辛苦到底是不是值得的。读研...保研可能很难保送到很好的学校，考研吧，又还很远。所以那个时候有点偷懒了，成绩也不是很好，天天就想着看演唱会、学音乐等等等等，和学习有关的倒是一点没干。
</p>
<p style="text-indent:2em">
第一个转折点来咯。寒假的时候，和林瀚还有南帆吃饭。林瀚无意间提了一句，说我英文还可以，要不要考个雅思，之后可以申港科大、港大之类的学校，排名高、也不贵。坦白讲，真的是很不经意的一句话，我真的记在心里了。回家后就开始关注这方面信息，在开学后也毫不犹豫报了培训班，开始每天的被折磨之路。
</p>
<p style="text-indent:2em">
2019年4月13日-7月20日，每一天在没有课余任务的时候，就都将自己投进去雅思。中间经历过太多次的绝望，太多次的心态爆炸。毕竟双非嘛，6.5肯定说不过去，至少也得有7。三个月来，做了几十套题，百分之95都是6.5，个别时候是6，从没有总分上过7。真的好多次想过要放弃，好多次想过不想学下去，当然，也想过退考试费~但是，要么不做，要做就做到最好。最后还是选择坚持下去。当其他同学在玩、在做着自己喜欢的科研项目的时候，我还在卑微刷题，卑微练口语、看写作...但是付出真的是值得的。8月2日12：00——听力8.0，阅读7.0，写作7.0，口语6.0，总分7.0。想都没有想过的总分，想都没有想过的写作...真的发生了。付出得到了回报。
</p>
<p style="text-indent:2em">
从那以后，我的申研之路就有了一点希望了，毕竟语言成绩还不错，接下来努力的方向就是成绩和科研项目了。当然，最感谢的还是老友的无意的一句话，让我开始去做，并做到自己的最好。很庆幸因为关注留学，知道申研还需要有科研经历，所以暑假阶段也开始透过同学去联系导师。这就开启了下一个章节啦。
</p>

<h2 id="大三：疲惫、充实和最关键的转折"><a href="#大三：疲惫、充实和最关键的转折" class="headerlink" title="大三：疲惫、充实和最关键的转折"></a>大三：疲惫、充实和最关键的转折</h2><p style="text-indent:2em">
进入大三，在若愚同学的推荐下，我进入课题组进行交通大数据相关课题的研究。大三上学期课真多，每天还要看论文，学机器学习、深度学习，真的非常累，但是自己每一天都在坚持，每一天都在进步。那个时候的目标还是奔着出境、出国准备的，所以刷分、科研等等，多线程，什么都不可以落下。截止大三上学期结束，我的均分掉了一点，89.76，科研还是无成果，不过自己有在进步。那个时候期末的选课，想着下学期是申研的最后一学期了，赶紧选多几门课，刷分刷GPA！
</p>
<p style="text-indent:2em">
寒假开始爆发的疫情真的是全世界的转折点，也是我的最重要的转折点。由于延迟开学，本来正常开学的日期也只能待在家，所以我向保研机构发送了自己的简历，也得到了初步的定位分析——假如能够拿到保研名额，211或者中等985都有戏。我靠！做梦都没想到有这样的机会！之后就去了解了下本校的推免名额加分政策，也在后续几个月里，熬夜通宵赶出能够加分、同时也能提升简历的材料。当然，自己并没有抱太大的希望，尽力申请，申请不到好学校就新加坡英国。
</p>
<p style="text-indent:2em">
五月底，第一个本专业相关的夏令营开放了——南开大学人工智能学院。那叫一个卷，快1000份简历，只进了100个面试，直接挂啦。那时候自己还发了条私密朋友圈，以为自己的保研外校之旅直接宣告失败了。也和琪姐说了这件事，她还安慰我，可能是不同招生老师和学生简历的眼缘不同。那时候还以为真的只是安慰而已，没想到...事实真的是这样子的。当然，后续的过程，实在太过戏剧性，就挑几个最关键的讲啦。
</p>

<h2 id="申请背景"><a href="#申请背景" class="headerlink" title="申请背景"></a>申请背景</h2><ul>
<li>院校及专业：双非一本，广东工业大学，自动化创新班；</li>
<li>成绩排名：夏令营7/255，预推免6/253；</li>
<li>英语能力：雅思7.0，六级532；</li>
<li>科研成果：中文核心与导师共同一作1篇，专利第一发明人3份；</li>
<li>学科竞赛：全国大学生英语竞赛一等奖，全国大学生数学竞赛三等奖；</li>
<li>奖学金：校级二等奖学金+校级三等奖学金+两次企业奖学金。</li>
</ul>
<h2 id="♠值得纪念的几件事♠"><a href="#♠值得纪念的几件事♠" class="headerlink" title="♠值得纪念的几件事♠"></a>♠值得纪念的几件事♠</h2><h3 id="1-第一个offer，让我看到希望"><a href="#1-第一个offer，让我看到希望" class="headerlink" title="1. 第一个offer，让我看到希望"></a>1. 第一个offer，让我看到希望</h3><p style="text-indent:2em">
后来关注了一个公众号，每天都会推送相关夏令营和预推免信息。看到的第二个本专业的夏令营，是山东大学的控制科学与工程学院举行的。老实讲我从来没考虑过这个学校，毕竟一直在南方，对北方的学校没啥了解，但是看到这个学院的名字，和我们学硕的名字一模一样。所以，吃完饭，赶紧投赶紧申上了。等结果的过程中，还投了湖南大学，看了下往年名单，觉得自己稳进。结果，学硕只给211/985，双非没戏。自己又绝望了一次，但是两天后收到山大面试通知，赶紧熬夜准备起来！
</p>
<p style="text-indent:2em">
山大的夏令营是线上群面，五位同学一组。好家伙，除了我，全是江苏211，学历当然打不过了。考核方式给了一个开放性问题——本科阶段觉得最有成就的一件事。要被我自己笑死，本来还想讲自己写歌送给周杰伦的事情哈哈哈。后来第一位女同学讲了自己的科研项目，然后老师用英文进行提问对答，之后的同学就都采用这种方式了。轮到我的时候，一看学历打不过啊，又会考察英文能力，我就直接开始英文solo了。之后的英文问答环节也很顺利。终于，收到了第一个offer。
</p>

<p><img data-src="/images/God-helps-those-who-help-themselves/sdu/summer_camp.jpg"></p>
<ul>
<li><p>VSIS实验室</p>
<p>拿到优营后，赶紧联系老师。翻到了VSIS实验室的主页，我靠这也太多顶会了吧…谁不心动呢…</p>
<p><img data-src="/images/God-helps-those-who-help-themselves/sdu/conference.jpg"></p>
<p>发了好几次邮件，才获得了导师组的面试机会。半个小时的面试，总结下来，老师很委婉，说各方面都还可以，但是基本只收本校的学生。懂啦，我没有他们学校的学生强，认了，毕竟自己太普通了。</p>
</li>
<li><p>CV方向年轻牛导</p>
<p>面试二轮浙大面试前，觉得自己应该没啥戏了，因为进面试的都是神仙…所以想着山大联系个老师就上了。VSIS也不咋搭理我，所以发邮件给另一位年轻老师，愿意收我的一位很厉害的老师！不过最后把老师咕咕了…老师倒还理解我，也没影响老师招生，还ok。</p>
</li>
</ul>
<h3 id="2-第二个offer，而且是top3，很开心！！！"><a href="#2-第二个offer，而且是top3，很开心！！！" class="headerlink" title="2. 第二个offer，而且是top3，很开心！！！"></a>2. 第二个offer，而且是top3，很开心！！！</h3><p style="text-indent:2em">
这个浙大工程师学院，真的是自己运气很好，八辈子修来的福分才得知的消息。首先就是自己的创新班师兄和我提了一下这个学院，后来我就去了解了一下。再后来，保研群里一位211的女生，也给我推荐了工院的项目，那时候还快赶上截止日期了。看到去年的面试名单，好多985啊...本着碰运气的心态，选了宁波分院车联网与大数据项目（是因为本部项目大部分不喜欢，数据科学的项目又很计算机，专业背景肯定不够）。结果...真的进面试了。
</p>
<p style="text-indent:2em">
考核方式，10分钟PPT+10分钟问答。我靠，面试名单各种中九、211还有一个C9。这不得用一手全英10分钟，不然我咋赢得过他们...三天准备时间，熬夜写稿背稿，复习项目、专业课...很极限的三天，面试的时候十分钟solo完也没啥特别的，好像老师也不是很在意。问的项目问题也蛮常规，还问了一个神经网络和控制论在倒立摆问题上有啥区别。听到问题的时候直接懵了，愣了五秒钟开始支支吾吾了。控制论是啥...我都不爱学本专业的，我就随便含糊了一下反馈blablabla的，然后重点都在讲机器学习/深度学习的思想。应该算是混过去了吧...最后结果，第二名哎，原来英文是真的会加分，哭了，还以为我太垃圾，老师都不爱搭理我也不想给我offer。
</p>

<p><img data-src="/images/God-helps-those-who-help-themselves/zju/summer_camp.jpg"></p>
<p style="text-indent:2em">
一言难尽，招生的时候宁波说优营=直接录取，但后来又闪烁其词，再后来变成优营直通第二轮预推免面试，而工院宁波分院也变成了专业学院宁波分院了...当然自己也会难过，因为稳的top3变成不稳的了，之前联系的计算机学院的老师，也因为取消项目制招生而选不了了。但她可是浙大啊！！！我忍！等预推免，争取通过。
</p>
<p style="text-indent:2em">
看到预推免控制学院复试名单，被吓到，九成中上游985+C9，还有一些211，双非少之又少。10.8的面试，意味着国庆期间要认真复习。害，复习效率很低，因为我知道浙大控制面试真的很难啊！！！所以那段时间真的好丧好down好blue，复习效果也就那样吧。志愿是肯定不敢一志愿报本部的，宁波分院表忠心。
</p>
<p style="text-indent:2em">
面试过程二十分钟，那叫一个折磨。一开口就是老传感器了，我说我不会...老师还看了下成绩单说，“你不是学过传感器吗？”场面一度尴尬，后面问了运动控制和系统控制的区别，不会，但又不能再直说不会了，就瞎答呗。答完，“这个和运动控制有关系吗？”场面第二次尴尬。后来问了下项目担任角色，再后来被问了一下还有没有别的项目（就是嫌我项目只有一个，太少了...）。我就提了下暑假的时候从基础学起的NLP小demo，这个真的是天意的安排了，不过这个就等讲中大的时候再说。一位女老师好善良，看我面试效果不是很好，就用英文提了个问题，还挺长的，问读研阶段要提升什么能力啥的。还好还好，答得还可以，算是在给我机会啊！！我还好没浪费。再再后来，又来了，让我解释PLC的中文名，还好，有点印象，对着缩写猜出来了。又让我说下现场总线的应用，我哪知道...就答了下当时做的大作业，Modbus主从站通信，直接给自己挖坑了，来了一个“Modbus各层协议能不能讲讲”。“老师我不会，太久没用了”（实际上就是已经忘了）。然后面试就结束了。
</p>
<p style="text-indent:2em">
面试完的那天早上和当天下午，那可真的太抑郁了。以为真的和浙大无缘了，我可不想去山东啊...毕竟南方人，去北方还是有点抵触。躺在酒店床上一动不动，饭也不吃，就看视频看到睡着，醒来接着颓废接着瘫。直到傍晚的时候出了面试结果，宁波分院拟录取，松了口大气，赶紧打电话报喜，拿筷子吃外卖的手都在抖啊...宁波我来了，浙大我来了。虽然说没办法去本部，害，神仙打架，能去浙大就不错了，还要啥自行车。
</p>
<p style="text-indent:2em">
等到推免正式结束后，也联系到了一位很好的老师，方向是大数据相关，都是我很感兴趣的方向。导师人也很好，也向导师门下的一位研一的学姐打探了些情况，各方面都是符合我心中的预期~然后在宁波其实也就大概呆个一年，之后实习肯定是去杭州嘛，所以其实真的没什么差。结果真的挺好的啦！
</p>


<p><img data-src="/images/God-helps-those-who-help-themselves/zju/pre_exemption.jpg"></p>
<h3 id="3-❤梦校❤"><a href="#3-❤梦校❤" class="headerlink" title="3. ❤梦校❤"></a>3. ❤梦校❤</h3><p style="text-indent:2em">
高中三年的梦，大学四年的梦，但最终还是只是一个梦。
</p>

<p><img data-src="/images/God-helps-those-who-help-themselves/sysu_dream/SYSU.jpg" alt="夜晚中大校门外，很美。"></p>
<p style="text-indent:2em">
中大算是推免准备阶段收集材料信息的第一个学校了，因为她真的是梦校、女神校。他们没有办双控的夏令营，在7月底的时候，点开了硕士生导师排序第一位的老师——沈颖老师的主页。天啊！自然语言处理，CCF A、数据挖掘顶刊，人还美丽大方。完美的女神老师的形象！！！刚好还在知乎上搜到沈老师的账号，秒关注！然后就斗胆发了下邮件给老师，得到了两道编程题考核的回复。马上着手学起来。第一道数据预处理的还蛮简单，第二道算法编程就有点难了...学了一个月从基础学起，愣是没做出来。后来预推免前把答案发给老师，还以为会让老师失望，结果她说帮我争取进面试哎...人美心善的好老师！PS.这次从基础学起的NLP相关知识，后来就成了我在浙大面试的时候讲的一个小项目，不过我可没提到沈老师的题目细节，因为要保密~所以说都是天意的安排啦。
</p>

<p><img data-src="/images/God-helps-those-who-help-themselves/sysu_dream/try.jpg"></p>
<p style="text-indent:2em">
10.4号出预推免面试名单，没有我呜呜呜。当晚就发了一封感谢信给沈老师，真的很遗憾没能进面试，彻底失去了成为最喜欢的老师的学生的机会了。老师的回复也真的让我很感动很感动。我其实真的太普通了，但是还是得到了老师的认可，自己很讶异。当然，我更抱着，不能让老师失望的心态，去准备浙大的面试。想着如果有幸能通过面试的话，把这个好消息告诉老师，她会更开心的。
</p>

<p><img data-src="/images/God-helps-those-who-help-themselves/sysu_dream/praise.jpg"></p>
<p style="text-indent:2em">
结局是通过啦，宁波分院嘛。把这个消息和老师讲了，她也替我开心！我没有让看好我的老师失望，以后也不会让她失望。
</p>

<p><img data-src="/images/God-helps-those-who-help-themselves/sysu_dream/final.jpg"></p>
<p style="text-indent:2em">
其实心里会有不甘，会有可惜，会有遗憾。但是我一直相信一句话：“如果事与愿违，一定另有安排。”
</p>
## 很多很多reject，和一些accept

<p style="text-indent:2em">
值得记录的面试和套磁环节基本上就结束啦，下面是一些投简历的情况和面试情况。
</p>

<table>
<thead>
<tr>
<th align="left">学校及专业</th>
<th align="left">夏令营</th>
<th align="left">预推免</th>
</tr>
</thead>
<tbody><tr>
<td align="left">南开大学人工智能学硕</td>
<td align="left">拒</td>
<td align="left">无预推免</td>
</tr>
<tr>
<td align="left">北京师范大学人工智能学硕</td>
<td align="left">拒</td>
<td align="left">没报</td>
</tr>
<tr>
<td align="left">北京航空航天大学自动化学硕</td>
<td align="left">拒</td>
<td align="left">没报</td>
</tr>
<tr>
<td align="left">东南大学控制学硕</td>
<td align="left">拒</td>
<td align="left">无预推免</td>
</tr>
<tr>
<td align="left">湖南大学控制学硕</td>
<td align="left">拒</td>
<td align="left">没报</td>
</tr>
<tr>
<td align="left">湖南大学计算机学硕</td>
<td align="left">没报</td>
<td align="left">拒</td>
</tr>
<tr>
<td align="left">大连理工大学计算机学硕</td>
<td align="left">没报</td>
<td align="left">拒</td>
</tr>
<tr>
<td align="left">华南理工大学控制学硕</td>
<td align="left">拒</td>
<td align="left">拒</td>
</tr>
<tr>
<td align="left">中山大学控制学硕</td>
<td align="left">无夏令营</td>
<td align="left">拒</td>
</tr>
<tr>
<td align="left">哈尔滨工业大学(深圳)控制学硕</td>
<td align="left">拒</td>
<td align="left">拒</td>
</tr>
<tr>
<td align="left">华中科技大学控制学硕</td>
<td align="left">无夏令营</td>
<td align="left">拒</td>
</tr>
<tr>
<td align="left">同济大学控制学硕</td>
<td align="left">无夏令营</td>
<td align="left">拒</td>
</tr>
<tr>
<td align="left">南方科技大学计算机学硕</td>
<td align="left">没报</td>
<td align="left">名额已经全满</td>
</tr>
<tr>
<td align="left">中科院集成所控制专硕</td>
<td align="left">没报</td>
<td align="left">拒</td>
</tr>
<tr>
<td align="left"><strong>南京航空航天大学计算机学硕</strong></td>
<td align="left"><strong>没报</strong></td>
<td align="left"><strong>进面试并通过</strong></td>
</tr>
<tr>
<td align="left"><strong>西安电子科技大学计算机学硕</strong></td>
<td align="left"><strong>没报</strong></td>
<td align="left"><strong>进面试，导师制，名额满</strong></td>
</tr>
<tr>
<td align="left"><strong>重庆大学控制学硕</strong></td>
<td align="left"><strong>进面试但放弃，请求补录其他同学</strong></td>
<td align="left"><strong>无预推免</strong></td>
</tr>
<tr>
<td align="left"><strong>中南大学控制学硕</strong></td>
<td align="left"><strong>拒</strong></td>
<td align="left"><strong>进面试并通过</strong></td>
</tr>
<tr>
<td align="left"><strong>电子科技大学控制学硕</strong></td>
<td align="left"><strong>拒</strong></td>
<td align="left"><strong>进面试但放弃，请求补录其他同学</strong></td>
</tr>
<tr>
<td align="left"><strong>中国科学技术大学科学岛控制专硕</strong></td>
<td align="left"><strong>没报</strong></td>
<td align="left"><strong>进面试但放弃，请求补录其他同学</strong></td>
</tr>
<tr>
<td align="left"><strong>山东大学控制学硕</strong></td>
<td align="left"><strong>进面试，优秀营员</strong></td>
<td align="left"><strong>不需报名预推免</strong></td>
</tr>
<tr>
<td align="left"><strong>浙江大学控制专硕</strong></td>
<td align="left"><strong>工程师学院宁波分院进面试，优秀营员</strong></td>
<td align="left"><strong>控制学院宁波分院直通面试，通过</strong></td>
</tr>
</tbody></table>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p style="text-indent:2em">
这三年，真的很不容易。当然悲伤的事情就不去回忆了，多记录一些感恩和美好吧。从最开始打算考研的想法，到后来为留学申请做准备，再到后来的推免...自己真的何其幸运，遇到那么好的老师，那么好的同学，还有无条件支持自己任何想法的家人们。特别是高中同学的一个考雅思的建议，直接就像是开启了新的一个篇章一样...还有之后接触科研项目，投学校，等等等等，自己真的运气好好，得到了太多人太多人的帮助。我没有浪费你们给我的善意和机会！这段拼尽全力去付出的经历，以后如果回想起来，不会遗憾，觉得值得，就足够了。
</p>
<p style="text-indent:2em">
小的时候看《十八岁的天空》，里面有一句台词特别酷：“God helps those who help themselves.”。坦白讲，小学的时候都不知道这句话什么意思，也看不懂语法，但就是莫名觉得这句话太酷了，自己也是一直记了下来。直到中学学了这句话有关的语法，慢慢地再结合自己一步步的经历，才越来越发现这句话的真理，也真正变成了自己的座右铭。天助自助者。其实哪有什么“天助”，上天哪会帮我，这只是指出现在我眼前的机会、机遇罢了。而我，也一直在实现“自助”，以后也会一直坚持。
</p>
<p style="text-indent:2em">
推免之路这几个月走来，其实一直会在想关于人性的事情——为什么不能够懂得满足呢？其实保研，能够去到比自己本科学校高一个档次的学校就很不错了：双非->211，211->985，985->C9...我拿到的这些机会也已经很好，甚至说非常好了，本专业的都是985，最开始拿到的山东大学的控制也是很好很好的录取了。可我还是不满足，想争取top3。top3拿到了之后呢，又在懊恼为什么没能去本部，即便毕业证各方面没差。其中这段时间，也是因为自己这方面心态上的想法而经常心情不好。我已经得到很棒的机会了，知足吧小朋友！说白了还是太“贪”，我觉得也无可厚非吧，年纪还小，有更好的当然要尽力去争取，当然，该知足的时候还是要知足~
</p>
<p style="text-indent:2em">
当然自己心里放不下的还是没能成为中大沈老师的学生，其实我的去向也很好了啊！浙大控制哎！也就上课辛苦点，还有没办法联系全部的导师而已，其余都是本部待遇了！但是...如果没有联系到沈颖老师，那其实中大把我reject了我还算能接受。但是...遇到一位这么好的老师，是真的非常非常不容易，再加上中大梦校的buff...真的觉得很可惜很遗憾。我想，这个又开心又难过的记忆，可能很难很难很难忘掉。安慰自己，人生嘛，留下点遗憾，挺好。
</p>
<p style="text-indent:2em">
Anyway，陈漪皓，这只是个开始，别得意，要走的路还很长。还有，别忘了，还有很多人等着你给他们争光。
</p>
<p style="text-indent:2em">
God helps those who help themselves.
</p>]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Feelings</tag>
      </tags>
  </entry>
</search>
